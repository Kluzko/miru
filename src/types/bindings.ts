
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async searchAnime(request: SearchAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAnimeById(request: GetAnimeByIdRequest) : Promise<Result<AnimeDetailed | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_by_id", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTopAnime(request: GetTopAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_top_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSeasonalAnime(request: GetSeasonalAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_seasonal_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchAnimeExternal(request: SearchAnimeExternalRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_anime_external", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAnimeByExternalId(request: GetAnimeByExternalIdRequest) : Promise<Result<AnimeDetailed | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_by_external_id", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCollection(request: CreateCollectionRequest) : Promise<Result<Collection, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollection(request: GetCollectionRequest) : Promise<Result<Collection | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllCollections() : Promise<Result<Collection[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_collections") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCollection(request: UpdateCollectionRequest) : Promise<Result<Collection, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteCollection(request: DeleteCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addAnimeToCollection(request: AddAnimeToCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_anime_to_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeAnimeFromCollection(request: RemoveAnimeFromCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_anime_from_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollectionAnime(request: GetCollectionAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateAnimeInCollection(request: UpdateAnimeInCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_anime_in_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importAnimeBatch(request: ImportAnimeBatchRequest) : Promise<Result<ImportBatchResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_anime_batch", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateAnimeTitles(request: ValidateAnimeTitlesRequest) : Promise<Result<EnhancedValidationResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_anime_titles", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importValidatedAnime(request: ImportValidatedAnimeRequest) : Promise<Result<ImportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_validated_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listProviders() : Promise<Result<ProviderInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_providers") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setPrimaryProvider(provider: AnimeProvider) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_primary_provider", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPrimaryProvider() : Promise<Result<AnimeProvider, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_primary_provider") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getEnabledProviders() : Promise<Result<AnimeProvider[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_enabled_providers") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getProviderRateLimit(provider: AnimeProvider) : Promise<Result<number, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_provider_rate_limit", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAgeRestrictions() : Promise<Result<AgeRestrictionInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_age_restrictions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getProviderHealthStatus() : Promise<Result<ProviderHealthInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_provider_health_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getProviderConfig(provider: AnimeProvider) : Promise<Result<ProviderConfig, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_provider_config", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateProviderConfig(request: UpdateProviderConfigRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_provider_config", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllProviderConfigs() : Promise<Result<ProviderConfig[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_provider_configs") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCacheStatistics() : Promise<Result<CacheStatistics[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cache_statistics") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async clearProviderCache(provider: AnimeProvider) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_provider_cache", { provider }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AddAnimeToCollectionRequest = { collection_id: string; anime_id: string; user_score: number | null; notes: string | null }
export type AgeRestrictionInfo = { provider: AnimeProvider; max_age: number | null; content_rating: string }
/**
 * Air date range for anime
 */
export type AiredDates = { from: string | null; to: string | null }
/**
 * Comprehensive anime entity with full information for detailed views
 */
export type AnimeDetailed = { id: string; title: AnimeTitle; providerMetadata: ProviderMetadata; score: number | null; favorites: number | null; synopsis: string | null; episodes: number | null; status: AnimeStatus; aired: AiredDates; animeType: AnimeType; ageRestriction: string | null; genres: Genre[]; studios: string[]; source: string | null; duration: string | null; imageUrl: string | null; bannerImage: string | null; trailerUrl: string | null; compositeScore: number; tier: AnimeTier; qualityMetrics: QualityMetrics; createdAt: string; updatedAt: string; lastSyncedAt: string | null }
/**
 * Supported anime data providers
 */
export type AnimeProvider = 
/**
 * Jikan (MyAnimeList API) - Default provider
 */
"jikan" | 
/**
 * AniList GraphQL API
 */
"anilist" | 
/**
 * Kitsu API
 */
"kitsu" | 
/**
 * TMDB for anime movies
 */
"tmdb" | 
/**
 * AniDB for detailed technical info
 */
"anidb"
export type AnimeStatus = "Airing" | "Finished" | "NotYetAired" | "Cancelled" | "Unknown"
export type AnimeTier = "S" | "A" | "B" | "C" | "D"
/**
 * Anime title information with multiple language variants
 */
export type AnimeTitle = { 
/**
 * Main title (usually from the primary provider)
 */
main: string; 
/**
 * English title
 */
english: string | null; 
/**
 * Japanese title (in Japanese characters)
 */
japanese: string | null; 
/**
 * Romanized Japanese title
 */
romaji: string | null; 
/**
 * Native language title (could be different from Japanese for non-JP anime)
 */
native: string | null; 
/**
 * Alternative titles and synonyms
 */
synonyms: string[] }
export type AnimeType = "TV" | "Movie" | "OVA" | "Special" | "ONA" | "Music" | "Unknown"
/**
 * Aggregate quality insights for a batch of anime
 */
export type BatchQualityInsights = { total_anime: number; average_quality_before: number; average_quality_after: number; common_gaps: Partial<{ [key in string]: number }>; provider_effectiveness: Partial<{ [key in string]: number }>; enhancement_summary: string[] }
export type CacheStatistics = { provider: AnimeProvider; hit_rate: number; total_entries: number; cache_size_bytes: number; last_cleared: string | null }
export type Collection = { id: string; name: string; description: string | null; animeIds: string[]; animeCount: number | null; createdAt: string; updatedAt: string }
export type CreateCollectionRequest = { name: string; description: string | null }
/**
 * Data quality metrics for imported anime
 */
export type DataQualityMetrics = { completeness_score: number; consistency_score: number; freshness_score: number; source_reliability: number; field_completeness: Partial<{ [key in string]: boolean }>; provider_agreements: Partial<{ [key in string]: number }> }
/**
 * Summary of data quality across all validated anime
 */
export type DataQualitySummary = { average_completeness: number; average_consistency: number; total_providers_used: number; most_reliable_provider: AnimeProvider | null; fields_with_gaps: string[] }
export type DeleteCollectionRequest = { id: string }
/**
 * Enhanced validated anime with comprehensive data from multiple providers
 */
export type EnhancedValidatedAnime = { input_title: string; anime_data: AnimeDetailed; data_quality: DataQualityMetrics; provider_sources: AnimeProvider[]; confidence_score: number }
/**
 * Enhanced validation result with comprehensive data analysis
 */
export type EnhancedValidationResult = { found: EnhancedValidatedAnime[]; not_found: ImportError[]; already_exists: ExistingAnime[]; total: number; average_confidence: number; data_quality_summary: DataQualitySummary }
export type ExistingAnime = { input_title: string; matched_title: string; matched_field: string; anime: AnimeDetailed }
export type Genre = { id: string; name: string }
export type GetAnimeByExternalIdRequest = { id: string; preferred_provider: AnimeProvider | null }
export type GetAnimeByIdRequest = { id: string }
export type GetCollectionAnimeRequest = { collection_id: string }
export type GetCollectionRequest = { id: string }
export type GetSeasonalAnimeRequest = { year: number; season: string; page: number }
export type GetTopAnimeRequest = { page: number; limit: number }
export type ImportAnimeBatchRequest = { titles: string[] }
export type ImportBatchResult = { imported_anime: ImportResult[]; quality_insights: BatchQualityInsights; providers_used: string[]; gaps_filled: number }
export type ImportError = { title: string; reason: string }
export type ImportResult = { imported: ImportedAnime[]; failed: ImportError[]; skipped: SkippedAnime[]; total: number }
export type ImportValidatedAnimeRequest = { validated_anime: ValidatedAnime[] }
export type ImportedAnime = { title: string; primary_external_id: string; provider: AnimeProvider; id: string }
export type ProviderConfig = { provider: AnimeProvider; enabled: boolean; priority: number; rate_limit: number; timeout_ms: number; retry_attempts: number; cache_duration_secs: number; api_key: string | null; base_url: string }
export type ProviderHealthInfo = { provider: AnimeProvider; is_healthy: boolean; success_rate: number; total_requests: number; consecutive_failures: number; avg_response_time_ms: number | null }
export type ProviderInfo = { provider: AnimeProvider; name: string; enabled: boolean; is_primary: boolean; rate_limit_per_minute: number }
/**
 * Provider-specific metadata for external IDs and synchronization
 */
export type ProviderMetadata = { 
/**
 * External IDs from different providers
 */
external_ids: Partial<{ [key in AnimeProvider]: string }>; 
/**
 * URLs to provider pages
 */
provider_urls: Partial<{ [key in AnimeProvider]: string }>; 
/**
 * User's preferred provider for primary data
 */
user_preferred_provider: AnimeProvider | null; 
/**
 * Current primary provider (can be different from user preference if not available)
 */
primary_provider: AnimeProvider }
export type QualityMetrics = { popularityScore: number; engagementScore: number; consistencyScore: number; audienceReachScore: number }
export type RemoveAnimeFromCollectionRequest = { collection_id: string; anime_id: string }
export type SearchAnimeExternalRequest = { query: string; limit: number | null }
export type SearchAnimeRequest = { query: string }
export type SkippedAnime = { title: string; external_id: string; provider: AnimeProvider; reason: string }
export type UpdateAnimeInCollectionRequest = { collection_id: string; anime_id: string; user_score: number | null; notes: string | null }
export type UpdateCollectionRequest = { id: string; name: string | null; description: string | null }
export type UpdateProviderConfigRequest = { provider: AnimeProvider; config: ProviderConfig }
export type ValidateAnimeTitlesRequest = { titles: string[] }
export type ValidatedAnime = { input_title: string; anime_data: AnimeDetailed }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
