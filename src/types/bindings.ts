// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async searchAnime(
    request: SearchAnimeRequest,
  ): Promise<Result<Anime[], string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("search_anime", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getAnimeById(
    request: GetAnimeByIdRequest,
  ): Promise<Result<Anime | null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_anime_by_id", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getTopAnime(
    request: GetTopAnimeRequest,
  ): Promise<Result<Anime[], string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_top_anime", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getSeasonalAnime(
    request: GetSeasonalAnimeRequest,
  ): Promise<Result<Anime[], string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_seasonal_anime", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async createCollection(
    request: CreateCollectionRequest,
  ): Promise<Result<Collection, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("create_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getCollection(
    request: GetCollectionRequest,
  ): Promise<Result<Collection | null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getAllCollections(): Promise<Result<Collection[], string>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_all_collections") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async updateCollection(
    request: UpdateCollectionRequest,
  ): Promise<Result<Collection, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("update_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async deleteCollection(
    request: DeleteCollectionRequest,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("delete_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async addAnimeToCollection(
    request: AddAnimeToCollectionRequest,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("add_anime_to_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async removeAnimeFromCollection(
    request: RemoveAnimeFromCollectionRequest,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("remove_anime_from_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async getCollectionAnime(
    request: GetCollectionAnimeRequest,
  ): Promise<Result<Anime[], string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_collection_anime", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async updateAnimeInCollection(
    request: UpdateAnimeInCollectionRequest,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("update_anime_in_collection", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async importAnimeBatch(
    request: ImportAnimeBatchRequest,
  ): Promise<Result<ImportResult, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_anime_batch", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async importFromCsv(
    request: ImportFromCsvRequest,
  ): Promise<Result<ImportResult, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("import_from_csv", { request }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type AddAnimeToCollectionRequest = {
  collection_id: string;
  anime_id: string;
  user_score: number | null;
  notes: string | null;
};
export type AiredDates = { from: string | null; to: string | null };
export type Anime = {
  id: string;
  malId: number | null;
  title: string;
  titleEnglish: string | null;
  titleJapanese: string | null;
  score: number | null;
  scoredBy: number | null;
  rank: number | null;
  popularity: number | null;
  members: number | null;
  favorites: number | null;
  synopsis: string | null;
  episodes: number | null;
  status: AnimeStatus;
  aired: AiredDates;
  animeType: AnimeType;
  rating: string | null;
  genres: Genre[];
  studios: string[];
  source: string | null;
  duration: string | null;
  imageUrl: string | null;
  malUrl: string | null;
  compositeScore: number;
  tier: AnimeTier;
  qualityMetrics: QualityMetrics;
};
export type AnimeStatus = "airing" | "finished" | "not_yet_aired" | "unknown";
export type AnimeTier = { name: string; level: number; color: string };
export type AnimeType =
  | "TV"
  | "Movie"
  | "OVA"
  | "Special"
  | "ONA"
  | "Music"
  | "Unknown";
export type Collection = {
  id: string;
  name: string;
  description: string | null;
  animeIds: string[];
  createdAt: string;
  updatedAt: string;
};
export type CreateCollectionRequest = {
  name: string;
  description: string | null;
};
export type DeleteCollectionRequest = { id: string };
export type Genre = { id: string; mal_id: number | null; name: string };
export type GetAnimeByIdRequest = { id: string };
export type GetCollectionAnimeRequest = { collection_id: string };
export type GetCollectionRequest = { id: string };
export type GetSeasonalAnimeRequest = {
  year: number;
  season: string;
  page: number;
};
export type GetTopAnimeRequest = { page: number; limit: number };
export type ImportAnimeBatchRequest = { titles: string[] };
export type ImportError = { title: string; reason: string };
export type ImportFromCsvRequest = { csv_content: string };
export type ImportResult = {
  imported: ImportedAnime[];
  failed: ImportError[];
  total: number;
};
export type ImportedAnime = {
  title: string;
  mal_id: number | null;
  id: string;
};
export type QualityMetrics = {
  popularityScore: number;
  engagementScore: number;
  consistencyScore: number;
  audienceReachScore: number;
};
export type RemoveAnimeFromCollectionRequest = {
  collection_id: string;
  anime_id: string;
};
export type SearchAnimeRequest = { query: string };
export type UpdateAnimeInCollectionRequest = {
  collection_id: string;
  anime_id: string;
  user_score: number | null;
  notes: string | null;
};
export type UpdateCollectionRequest = {
  id: string;
  name: string | null;
  description: string | null;
};

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: "ok"; data: T }
  | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case "listen":
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case "once":
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case "emit":
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}
