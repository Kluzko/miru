
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async searchAnime(request: SearchAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAnimeById(request: GetAnimeByIdRequest) : Promise<Result<AnimeDetailed | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_by_id", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTopAnime(request: GetTopAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_top_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSeasonalAnime(request: GetSeasonalAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_seasonal_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchAnimeExternal(request: SearchAnimeExternalRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_anime_external", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAnimeByExternalId(request: GetAnimeByExternalIdRequest) : Promise<Result<AnimeDetailed | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_by_external_id", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAnimeRelations(request: GetRelationsRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_relations", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Automatically enrich anime data when loading anime details
 * 
 * This command runs automatically when an anime detail page loads.
 * It silently checks for missing provider data and enriches it in the background.
 */
async autoEnrichOnLoad(request: AutoEnrichRequest) : Promise<Result<AutoEnrichResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("auto_enrich_on_load", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get anime with relations using optimized batch approach
 * 
 * This command fetches complete anime data with relation metadata in a single call.
 * If no relations exist in the database, the backend automatically discovers and saves them
 * from AniList before returning the results.
 * 
 * Returns a vector of related anime with their relation types and sync timestamps.
 */
async getAnimeWithRelations(animeId: string) : Promise<Result<AnimeWithRelationMetadata[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_with_relations", { animeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCollection(request: CreateCollectionRequest) : Promise<Result<Collection, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollection(request: GetCollectionRequest) : Promise<Result<Collection | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllCollections() : Promise<Result<Collection[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_collections") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCollection(request: UpdateCollectionRequest) : Promise<Result<Collection, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteCollection(request: DeleteCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addAnimeToCollection(request: AddAnimeToCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_anime_to_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeAnimeFromCollection(request: RemoveAnimeFromCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_anime_from_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollectionAnime(request: GetCollectionAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateAnimeInCollection(request: UpdateAnimeInCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_anime_in_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importAnimeBatch(request: ImportAnimeBatchRequest) : Promise<Result<ImportBatchResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_anime_batch", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateAnimeTitles(request: ValidateAnimeTitlesRequest) : Promise<Result<EnhancedValidationResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_anime_titles", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importValidatedAnime(request: ImportValidatedAnimeRequest) : Promise<Result<ImportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_validated_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get basic franchise relations (AniList exclusive - optimized GraphQL)
 * 
 * This command provides basic relationship discovery using AniList's superior GraphQL API.
 * Performance: ~0.4-1.0 seconds vs 10+ seconds with other providers.
 */
async getFranchiseRelations(animeId: number) : Promise<Result<AnimeRelation[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_franchise_relations", { animeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Discover complete franchise with detailed metadata (AniList exclusive)
 * 
 * Returns comprehensive franchise data including titles, years, episodes, and formats.
 * Uses single GraphQL call for entire franchise discovery - vastly superior to REST APIs.
 * Performance: Complete franchise (74+ items) discovered in <1 second.
 */
async discoverFranchiseDetails(animeId: number) : Promise<Result<FranchiseRelation[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discover_franchise_details", { animeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Discover and categorize complete franchise (AniList exclusive - RECOMMENDED)
 * 
 * The most comprehensive franchise discovery method available.
 * Returns franchise content intelligently categorized into:
 * - Main Story: Core seasons and sequels in chronological order
 * - Side Stories: Spin-offs and alternate storylines
 * - Movies: Theatrical releases
 * - OVAs/Specials: Additional content and extras
 * - Other: Miscellaneous relations
 * 
 * Performance: Complete categorized franchise in 0.4-2.2 seconds
 */
async discoverCategorizedFranchise(animeId: number) : Promise<Result<CategorizedFranchise, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discover_categorized_franchise", { animeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get relationship discovery capabilities and performance information
 * 
 * Returns information about why relationship discovery is AniList-exclusive
 * and performance comparisons with other providers.
 */
async getRelationshipCapabilities() : Promise<Result<RelationshipCapabilities, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_relationship_capabilities") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AddAnimeToCollectionRequest = { collection_id: string; anime_id: string; user_score: number | null; notes: string | null }
/**
 * Air date range for anime
 */
export type AiredDates = { from: string | null; to: string | null }
/**
 * Comprehensive anime entity with full information for detailed views
 */
export type AnimeDetailed = { id: string; title: AnimeTitle; providerMetadata: ProviderMetadata; score: number | null; rating: number | null; favorites: number | null; synopsis: string | null; description: string | null; episodes: number | null; status: AnimeStatus; aired: AiredDates; animeType: AnimeType; ageRestriction: UnifiedAgeRestriction | null; genres: Genre[]; studios: string[]; source: string | null; duration: string | null; imageUrl: string | null; images: string | null; bannerImage: string | null; trailerUrl: string | null; compositeScore: number; tier: AnimeTier; qualityMetrics: QualityMetrics; createdAt: string; updatedAt: string; lastSyncedAt: string | null }
/**
 * Supported anime data providers
 */
export type AnimeProvider = 
/**
 * Jikan (MyAnimeList API) - Default provider
 */
"jikan" | 
/**
 * AniList GraphQL API
 */
"anilist" | 
/**
 * Kitsu API
 */
"kitsu" | 
/**
 * TMDB for anime movies
 */
"tmdb" | 
/**
 * AniDB for detailed technical info
 */
"anidb"
/**
 * Simple anime relation for basic relationship queries
 */
export type AnimeRelation = { id: number; relation_type: string }
export type AnimeStatus = "Airing" | "Finished" | "NotYetAired" | "Cancelled" | "Unknown"
export type AnimeTier = "S" | "A" | "B" | "C" | "D"
/**
 * Anime title information with multiple language variants
 */
export type AnimeTitle = { 
/**
 * Main title (usually from the primary provider)
 */
main: string; 
/**
 * English title
 */
english: string | null; 
/**
 * Japanese title (in Japanese characters)
 */
japanese: string | null; 
/**
 * Romanized Japanese title
 */
romaji: string | null; 
/**
 * Native language title (could be different from Japanese for non-JP anime)
 */
native: string | null; 
/**
 * Alternative titles and synonyms
 */
synonyms: string[] }
export type AnimeType = "TV" | "Movie" | "OVA" | "Special" | "ONA" | "Music" | "Unknown"
/**
 * Anime with relation metadata for batch fetching
 */
export type AnimeWithRelationMetadata = { anime: AnimeDetailed; relation_type: string; synced_at: string }
export type AutoEnrichRequest = { animeId: string }
export type AutoEnrichResult = { animeId: string; enrichmentPerformed: boolean; providersFound: string[]; shouldReload: boolean }
/**
 * Aggregate quality insights for a batch of anime
 */
export type BatchQualityInsights = { total_anime: number; average_quality_before: number; average_quality_after: number; common_gaps: Partial<{ [key in string]: number }>; provider_effectiveness: Partial<{ [key in string]: number }>; enhancement_summary: string[] }
/**
 * Categorized franchise information organized by content type
 */
export type CategorizedFranchise = { main_story: FranchiseRelation[]; side_stories: FranchiseRelation[]; movies: FranchiseRelation[]; ovas_specials: FranchiseRelation[]; other: FranchiseRelation[] }
export type Collection = { id: string; name: string; description: string | null; animeIds: string[]; animeCount: number | null; createdAt: string; updatedAt: string }
export type CreateCollectionRequest = { name: string; description: string | null }
/**
 * Data quality metrics for imported anime
 */
export type DataQualityMetrics = { completeness_score: number; consistency_score: number; freshness_score: number; source_reliability: number; field_completeness: Partial<{ [key in string]: boolean }>; provider_agreements: Partial<{ [key in string]: number }> }
/**
 * Summary of data quality across all validated anime
 */
export type DataQualitySummary = { average_completeness: number; average_consistency: number; total_providers_used: number; most_reliable_provider: AnimeProvider | null; fields_with_gaps: string[] }
export type DeleteCollectionRequest = { id: string }
/**
 * Enhanced validated anime with comprehensive data from multiple providers
 */
export type EnhancedValidatedAnime = { input_title: string; anime_data: AnimeDetailed; data_quality: DataQualityMetrics; provider_sources: AnimeProvider[]; confidence_score: number }
/**
 * Enhanced validation result with comprehensive data analysis
 */
export type EnhancedValidationResult = { found: EnhancedValidatedAnime[]; not_found: ImportError[]; already_exists: ExistingAnime[]; total: number; average_confidence: number; data_quality_summary: DataQualitySummary; validation_duration_ms: number }
export type ExistingAnime = { input_title: string; matched_title: string; matched_field: string; anime: AnimeDetailed }
/**
 * Detailed franchise relation information for testing and verification
 */
export type FranchiseRelation = { id: number; title: string; relation_type: string; format: string | null; status: string | null; episodes: number | null; start_year: number | null }
export type Genre = { id: string; name: string }
export type GetAnimeByExternalIdRequest = { id: string; preferred_provider: AnimeProvider | null }
export type GetAnimeByIdRequest = { id: string }
export type GetCollectionAnimeRequest = { collection_id: string }
export type GetCollectionRequest = { id: string }
export type GetRelationsRequest = { anime_id: string }
export type GetSeasonalAnimeRequest = { year: number; season: string; page: number }
export type GetTopAnimeRequest = { page: number; limit: number }
export type ImportAnimeBatchRequest = { titles: string[] }
export type ImportBatchResult = { imported_anime: ImportResult[]; quality_insights: BatchQualityInsights; providers_used: string[]; gaps_filled: number }
export type ImportError = { title: string; reason: string }
export type ImportResult = { imported: ImportedAnime[]; failed: ImportError[]; skipped: SkippedAnime[]; total: number; duration_ms: number }
export type ImportValidatedAnimeRequest = { validated_anime: ValidatedAnime[] }
export type ImportedAnime = { title: string; primary_external_id: string; provider: AnimeProvider; id: string }
/**
 * Performance comparison between AniList and other providers
 */
export type PerformanceComparison = { anilist_calls: number; other_provider_calls: number; anilist_time_seconds: number; other_provider_time_seconds: number; efficiency_multiplier: number }
/**
 * Provider-specific metadata for external IDs and synchronization
 */
export type ProviderMetadata = { 
/**
 * External IDs from different providers
 */
external_ids: Partial<{ [key in AnimeProvider]: string }>; 
/**
 * URLs to provider pages
 */
provider_urls: Partial<{ [key in AnimeProvider]: string }>; 
/**
 * User's preferred provider for primary data
 */
user_preferred_provider: AnimeProvider | null; 
/**
 * Current primary provider (can be different from user preference if not available)
 */
primary_provider: AnimeProvider }
export type QualityMetrics = { popularityScore: number; engagementScore: number; consistencyScore: number; audienceReachScore: number }
/**
 * Information about relationship discovery capabilities
 */
export type RelationshipCapabilities = { supported_provider: AnimeProvider; reasons_for_exclusivity: string[]; performance_comparison: PerformanceComparison }
export type RemoveAnimeFromCollectionRequest = { collection_id: string; anime_id: string }
export type SearchAnimeExternalRequest = { query: string; limit: number | null }
export type SearchAnimeRequest = { query: string }
export type SkippedAnime = { title: string; external_id: string; provider: AnimeProvider; reason: string }
/**
 * Unified age restriction system that maps all provider age restrictions to a common standard
 */
export type UnifiedAgeRestriction = 
/**
 * G - All Ages (0+)
 */
"GeneralAudiences" | 
/**
 * PG13 - Parental Guidance for 13+
 */
"ParentalGuidance13" | 
/**
 * PG17 - Parental Guidance for 17+
 */
"ParentalGuidance17" | 
/**
 * Mature - Mature content (17+)
 */
"Mature" | 
/**
 * Explicit - Explicit sexual content (18+)
 */
"Explicit"
export type UpdateAnimeInCollectionRequest = { collection_id: string; anime_id: string; user_score: number | null; notes: string | null }
export type UpdateCollectionRequest = { id: string; name: string | null; description: string | null }
export type ValidateAnimeTitlesRequest = { titles: string[] }
export type ValidatedAnime = { input_title: string; anime_data: AnimeDetailed }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
