
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async searchAnime(request: SearchAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAnimeById(request: GetAnimeByIdRequest) : Promise<Result<AnimeDetailed | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_anime_by_id", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getTopAnime(request: GetTopAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_top_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSeasonalAnime(request: GetSeasonalAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_seasonal_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCollection(request: CreateCollectionRequest) : Promise<Result<Collection, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollection(request: GetCollectionRequest) : Promise<Result<Collection | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAllCollections() : Promise<Result<Collection[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_collections") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCollection(request: UpdateCollectionRequest) : Promise<Result<Collection, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteCollection(request: DeleteCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addAnimeToCollection(request: AddAnimeToCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_anime_to_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeAnimeFromCollection(request: RemoveAnimeFromCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_anime_from_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCollectionAnime(request: GetCollectionAnimeRequest) : Promise<Result<AnimeDetailed[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_collection_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateAnimeInCollection(request: UpdateAnimeInCollectionRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_anime_in_collection", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importAnimeBatch(request: ImportAnimeBatchRequest) : Promise<Result<ImportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_anime_batch", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importFromCsv(request: ImportFromCsvRequest) : Promise<Result<ImportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_from_csv", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async validateAnimeTitles(request: ValidateAnimeTitlesRequest) : Promise<Result<ValidationResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_anime_titles", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async importValidatedAnime(request: ImportValidatedAnimeRequest) : Promise<Result<ImportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("import_validated_anime", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get list of all providers with their status
 */
async listProviders() : Promise<Result<ProvidersListResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_providers") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Set the primary provider
 */
async setPrimaryProvider(request: SetPrimaryProviderRequest) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_primary_provider", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the current primary provider
 */
async getPrimaryProvider() : Promise<Result<AnimeProvider, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_primary_provider") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get enabled providers
 */
async getEnabledProviders() : Promise<Result<AnimeProvider[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_enabled_providers") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get rate limit info for a specific provider
 */
async getProviderRateLimit(request: GetProviderRateLimitRequest) : Promise<Result<RateLimiterInfo | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_provider_rate_limit", { request }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all age restrictions with display names for frontend
 */
async getAgeRestrictions() : Promise<Result<AgeRestrictionInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_age_restrictions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AddAnimeToCollectionRequest = { collection_id: string; anime_id: string; user_score: number | null; notes: string | null }
/**
 * Age restriction information for frontend display
 */
export type AgeRestrictionInfo = { 
/**
 * The enum variant name
 */
variant: string; 
/**
 * User-friendly display name
 */
display_name: string; 
/**
 * Description for UI
 */
description: string; 
/**
 * Minimum age
 */
min_age: number }
/**
 * Air date range for anime
 */
export type AiredDates = { from: string | null; to: string | null }
/**
 * Comprehensive anime entity with full information for detailed views
 */
export type AnimeDetailed = { id: string; title: AnimeTitle; providerMetadata: ProviderMetadata; score: number | null; favorites: number | null; synopsis: string | null; episodes: number | null; status: AnimeStatus; aired: AiredDates; animeType: AnimeType; ageRestriction: string | null; genres: Genre[]; studios: string[]; source: string | null; duration: string | null; imageUrl: string | null; bannerImage: string | null; trailerUrl: string | null; compositeScore: number; tier: AnimeTier; qualityMetrics: QualityMetrics; createdAt: string; updatedAt: string; lastSyncedAt: string | null }
/**
 * Supported anime data providers
 */
export type AnimeProvider = 
/**
 * Jikan (MyAnimeList API) - Default provider
 */
"jikan" | 
/**
 * AniList GraphQL API
 */
"anilist" | 
/**
 * Kitsu API
 */
"kitsu" | 
/**
 * TMDB for anime movies
 */
"tmdb" | 
/**
 * AniDB for detailed technical info
 */
"anidb"
export type AnimeStatus = "Airing" | "Finished" | "NotYetAired" | "Cancelled" | "Unknown"
export type AnimeTier = "S" | "A" | "B" | "C" | "D"
/**
 * Anime title information with multiple language variants
 */
export type AnimeTitle = { 
/**
 * Main title (usually from the primary provider)
 */
main: string; 
/**
 * English title
 */
english: string | null; 
/**
 * Japanese title (in Japanese characters)
 */
japanese: string | null; 
/**
 * Romanized Japanese title
 */
romaji: string | null; 
/**
 * Native language title (could be different from Japanese for non-JP anime)
 */
native: string | null; 
/**
 * Alternative titles and synonyms
 */
synonyms: string[] }
export type AnimeType = "TV" | "Movie" | "OVA" | "Special" | "ONA" | "Music" | "Unknown"
export type Collection = { id: string; name: string; description: string | null; animeIds: string[]; animeCount: number | null; createdAt: string; updatedAt: string }
export type CreateCollectionRequest = { name: string; description: string | null }
export type DeleteCollectionRequest = { id: string }
export type ExistingAnime = { input_title: string; matched_title: string; matched_field: string; anime: AnimeDetailed }
export type Genre = { id: string; name: string }
export type GetAnimeByIdRequest = { id: string }
export type GetCollectionAnimeRequest = { collection_id: string }
export type GetCollectionRequest = { id: string }
export type GetProviderRateLimitRequest = { provider: AnimeProvider }
export type GetSeasonalAnimeRequest = { year: number; season: string; page: number }
export type GetTopAnimeRequest = { page: number; limit: number }
export type ImportAnimeBatchRequest = { titles: string[]; collection_id: string | null }
export type ImportError = { title: string; reason: string }
export type ImportFromCsvRequest = { csv_content: string; collection_id: string | null }
export type ImportResult = { imported: ImportedAnime[]; failed: ImportError[]; skipped: SkippedAnime[]; total: number }
export type ImportValidatedAnimeRequest = { validated_anime: ValidatedAnime[] }
export type ImportedAnime = { title: string; primary_external_id: string; provider: AnimeProvider; id: string }
/**
 * Provider-specific metadata for external IDs and synchronization
 */
export type ProviderMetadata = { 
/**
 * External IDs from different providers
 */
external_ids: Partial<{ [key in AnimeProvider]: string }>; 
/**
 * URLs to provider pages
 */
provider_urls: Partial<{ [key in AnimeProvider]: string }>; 
/**
 * User's preferred provider for primary data
 */
user_preferred_provider: AnimeProvider | null; 
/**
 * Current primary provider (can be different from user preference if not available)
 */
primary_provider: AnimeProvider }
export type ProviderStatus = { provider: AnimeProvider; is_primary: boolean; enabled: boolean; rate_limit_info: RateLimiterInfo | null }
export type ProvidersListResponse = { providers: ProviderStatus[]; primary_provider: AnimeProvider }
export type QualityMetrics = { popularityScore: number; engagementScore: number; consistencyScore: number; audienceReachScore: number }
/**
 * Rate limiter information from the actual client implementation
 */
export type RateLimiterInfo = { 
/**
 * Requests per second
 */
requests_per_second: number; 
/**
 * Requests per minute (derived)
 */
requests_per_minute: number; 
/**
 * Minimum delay between requests (in milliseconds)
 */
min_delay_ms: number }
export type RemoveAnimeFromCollectionRequest = { collection_id: string; anime_id: string }
export type SearchAnimeRequest = { query: string }
export type SetPrimaryProviderRequest = { provider: AnimeProvider }
export type SkippedAnime = { title: string; external_id: string; provider: AnimeProvider; reason: string }
export type UpdateAnimeInCollectionRequest = { collection_id: string; anime_id: string; user_score: number | null; notes: string | null }
export type UpdateCollectionRequest = { id: string; name: string | null; description: string | null }
export type ValidateAnimeTitlesRequest = { titles: string[] }
export type ValidatedAnime = { input_title: string; anime_data: AnimeDetailed }
export type ValidationResult = { found: ValidatedAnime[]; not_found: ImportError[]; already_exists: ExistingAnime[]; total: number }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
